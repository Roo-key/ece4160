---
layout: post
title: Lab 2
description: Bluetooth
image: 
nav-menu: true
---
<section id="content">

<h2>Objective</h2>

<p>The purpose of lab 2 was to establish a working bluetooth connection between the computer and Artemis board. Other goals include downloading the various tools required to establish said bluetooth connection, as well as to gain familiarity with the Bluetooth Low Energy (BLE) Arduino library which can be learnt about in more detail <a href="https://www.arduino.cc/reference/en/libraries/arduinoble/" >here.</a></p>

<h2>Prelab Setup</h2>
<p>For the current and all future labs, the latest version of Python, version 3.10,  was installed from the <a href="https://www.python.org/downloads/">official website</a>. A virtual environment was set up using the command line actions: 
<blockquote>python3 -m pip install --user virtualenv</blockquote>
<blockquote>python3 -m venv FastRobots_ble</blockquote>
<blockquote>.\FastRobots_ble\Scripts\activate</blockquote>
Within the virtual environment, various packages were installed using the following command line action:
<blockquote>pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab</blockquote>
The coding for this lab will be done via Jupyter notebook as a Python IDE, as well as a course-provided code base. The Jupyter notebook was opened using the command line action:
<blockquote>jupyter lab</blockquote>
</p>

<h2>Setup</h2>
<p>The course-provided .ino Arduino file was burned onto the Artemis board, which outputs its MAC address into the serial monitor via the following code:
<blockquote>Serial.println(BLE.address());</blockquote>
![MAC Address](./assets/images/lab2/mac.png)
Unique bluetooth UUIDs were generated by the command line commands:
<blockquote>from uuid import uuid4</blockquote>
<blockquote>uuid4()</blockquote>
The unique uuid4's are used in the <b>connection.yaml</b> file of the Jupyter notebook, as well as the string and float characteristics of the Arduino code to ensure the computer can communicate with the Artemis board via unique addresses. The computer can connect to the Artemis board using the Python method <b>ble.connect()</b>:
<blockquote># Get ArtemisBLEController object</blockquote>
<blockquote>ble = get_ble_controller()</blockquote>
<blockquote># Connect to the Artemis Device</blockquote>
<blockquote>ble.connect()</blockquote>
![ble.connect](./assets/images/lab2/connection.png)
The computer will search for nearby bluetooth devices with the same UUID as defined in the connection.yaml file. This same UUID is used to identify the Artemis board!
</p>

<h2>Task 1: ECHO</h2>
<p>The first task involved creating a new command type <i>ECHO</i>, which passes a string to the Artemis board's <b>rx_characteristic_string</b>. This string can then be receive back from the Artemims board.
![task1](./assets/images/lab2/task1.png)
On the Arduino side, the code involves receiving the character array that is passed by the computer, appending it to an Estring value, and writing the new Estring value to the Artemis board's <b>tx_characteristic_string</b>. Some portions of the code are shown below:
<blockquote>case ECHO:
            char char_arr[MAX_MSG_SIZE];
            tx_estring_value.clear();
            tx_estring_value.append(char_arr);
            tx_characteristic_string.writeValue(tx_estring_value.c_str());
            break;
</blockquote>
</p>

<h2>Task 2: GET_TIME_MILLIS </h2>
<p>The next task is similar to the first in that we'd like to write a value to the string character. Instead of passing the string value from the computer, the <b>millis()</b> Arduino function was used to get the current time in milliseconds.
![task1](./assets/images/lab2/task2.png)
<blockquote>#Paraphrased code snippets
            int time = millis();
            tx_estring_value.append(time);
            tx_characteristic_string.writeValue(tx_estring_value.c_str());
</blockquote>
</p>

<h2>Task 3: Notification Handler</h2>
<p>For task 3, a Python notification handler was built. When the notification handler is started, any changes to the bluetooth characteristic of interest will be notified of to the computer. A notification handler is started with the method <b>ble.start_notify(ble.uuid['RX_STRING'], callback)</b>, where <b>RX_STRING</b> is the characteristic we want to be notified of changes to, and where <b>callback</b> is the the callback function. 
![task1](./assets/images/lab2/task3.png)
</p>

<h2>Task 4: GET_TEMP_5s</h2>
<p>The command GET_TEMP_5s uses the same logic as tasks 1 and 2 to get the internal die temperature of the Artemis board temperature sensor. The library functions <b>getTempDegF()</b> and <b>getTempDegC()</b> correspond to the temperature in fahrenheit and celsius respectively. Temperature data was updated once per second over the course of 5 seconds. The below image shows the results of the command after enabling the notification handler.
![task1](./assets/images/lab2/task4.png)
<blockquote>    #Paraphrased code snippets
                for (int i = 0; i < 5; i++){
                    float temp_f = getTempDegF();
                    float temp_c = getTempDegC();
                    tx_estring_value.append(temp_f);
                    tx_estring_value.append(temp_c);
                    tx_characteristic_string.writeValue(tx_estring_value.c_str());
                    delay(1000);
                }
</blockquote>
</p>

<h2>Task 5:</h2>
<p>Task 5 is identical to task 4 but involves updating the temperature more times over the same time frame. To accomplish this, a shorter delay and larger loop were used.
![task1](./assets/images/lab2/task5.png)
<blockquote>#Paraphrased code snippets
            for (int i = 0; i < 50; i++){
                float temp_f = getTempDegF();
                float temp_c = getTempDegC();
                tx_estring_value.append(temp_f);
                tx_estring_value.append(temp_c);
                tx_characteristic_string.writeValue(tx_estring_value.c_str());
                delay(100);
            }
</blockquote>
</p>

<h2>Task 6:</h2>
<p>The Artemis board has 384 kB of RAM. Because of this physical memory limitation, much of the processing must be done on the board itself before communication with the computer. Assuming 16-bit values are taken at 150 Hz, approximately 2400 bits or 300 bytes are written in one second. The board can collect data at this rate for 1280 seconds before running out of memory space.
</p>